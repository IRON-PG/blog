---
title: "CH1. 타입 ~ CH.2 값"
metaTitle: "You don't Know JS Study-01"
metaDescription: "CH1. 타입 ~ CH.2 값"
author: "yuuil"
date: "2022-10-22"
---
# 1. 타입

- 자바스크립트에서의 타입은 ECMAScript 언어 타입과 명세 타입으로 구분됨
- 언어 타입이 우리가 흔히 생각하는 값들의 타입

## 내장 타입

- `Undefined, Null, Boolean, String, Number, Object, Symbol(ES6+)`
- 값의 타입은 `typeof` 연산자로 알 수 있음
    - 예외)
        - `typeof null // "object"`
        - `typeof function() {/* */} // "function"`
- 값은 타입을 가지지만 변수에는 타입이 없음

## undefined vs undeclared

- undefined - 접근 가능한 스코프에 변수가 선언되었으나 현재 아무런 값도 할당되지 않은 상태
- undeclared - 접근 가능한 스코프에 변수가 선언되지 않은 상태
    - `typeof` 의 안전 가드로 인해 undeclared 변수의 typeof 결과값도 `undefined`

# 2. 타입

## 배열

- `delete` 연산을 이용해 슬롯을 제거할 수 있지만 `length` 프로퍼티는 변하지 않음
- 빈 슬롯의 값은 `undefined` 이지만 슬롯의 값은 `undefined` 로 세팅한 것과 명시적으로 똑같지 않음
- 배열은 하나의 객체이지 때문에 키/프로퍼티가 문자열인 값을 추가할 수 있음
    - `length` 가 증가하지는 않음
    - **그러나 표준 10진수 숫자로 바뀔 수 있는 문자열이라면 숫자 키를 사용한 것 같은 결과**

## 문자열

- 문자열은 불변 값, 배열은 가변 값
    - 문자열 메서드는 새로운 문자열을 생성한 후 반환
    - 배열 메서드는 바로 원소를 수정

## 숫자

- 숫자 리터럴은 10진수 리터럴로 표시
    - 소수점 앞 정수가 0이면 생략 가능 ex) 0.42, .42
    - 소수점 이하가 0일 때도 생략 가능 ex) 42.0, 42.
    - 위의 표현 방식은 메서드를 쓸 때 주의해야 함 ~~(누군가에게 억하심정 있는 거 아니라면 굳이 쓰지 말자)~~
    
    ```jsx
    42.toFixed(3) // SyntaxError
    
    (42).toFixed(3) // "42.000"
    0.42.toFixed(3) // "0.420"
    42..toFixed(3) // "42.000"
    42 .toFixed(3) // "42.000"
    ```
    
- 부동 소수점 문제
    
    ```jsx
    0.1 + 0.2 == 0.3 // false
    ```
    
    - ~~누가 봐도 `true`인데 장난하냐~~
    - 실수를 이진수의 형태로 저장하기 때문에 무한 소수(0.333333…)의 형태도 마지막은 2나 4로 표현함
    - 부동 소수점으로 나타내면 0.1과 0.2도 원래 숫자와 다르기 때문에 결과 값인 0.3도 아주 작은 오차를 가짐
    - 이런 상황에서 미세한 오차를 허용할 수 있는 것이 머신 입실론(컴퓨터가 다룰 수 있는 가장 작은 임계 값)
        - `Number.EPSILON`
- 정수 범위
    - 자바스크립트에서 정수는 53비트로 표현 (`Number.MAX_VALUE = 2e53-1`)
    - 64비트 숫자를 나타내려면 string 타입으로 저장해야 함
        - BigInteger 라이브러리를 사용하거나
    - 비트 연산 같은 32비트 숫자만 가능한 연산이 있기 때문에 실제 정수의 안전 범위는 -2^31 ~ 2^31-1

## 특수 값

### undefined vs null

- undefined 타입의 값은 undefined 뿐이고, null 타입의 값도 null 뿐임
    - 두 값의 사용 의미를 정의하는 방식은 개발자마다 다르지만 여기서는 논외
    - 놀랍게도 undefined는 식별자로 사용할 수 있음 ~~(정말 제정신이 아님)~~ 물론 strict mode에선 안 됨

### void

- 어떤 값이든 무효로 만듦
    - 결과값을 `undefined` 로 만듦
    - 기존 값은 건드리지 않고 연산 후의 값은 복구할 수 없음
- 표현식의 결과값이 없다는 걸 밝힐 때 요긴

### NaN

- 숫자 연산 중에 실패한 에러 상황을 나타냄
- NaN은 어떤 NaN과 동등하지 않은 유일무이한 값
    - `NaN !== NaN` , x === x로 식별할 수 없음
- ES6+ 에서는 `Number.isNaN()` 로 식별할 수 있으며, 폴리필은 `n !== n`

### 무한대

- Divide by zero 문제 없이 0으로 나누면 Infinity, 분자가 음수면 -Infinity

### 0

- +0(일반적인 0)과 -0 존재 ~~(갑자기 분위기 극한값)~~
- -0을 문자열화 하면 항상 “0”인데 “-0”을 숫자로 변환하면 -0이 됨
- 비교 연산 결과도 `-0 === 0 // true`
- 변수의 이동 방향을 알아야 할 때 유용함

NaN과 -0을 동등 비교하기 위해 ES6+부터는 `Object.is()` 를 사용할 수 있음

- 기본 연산자보다 효율이 떨어지기 때문에 일반적인 비교에서는 사용하지 않는 게 좋음

## 값 vs 레퍼런스

- 자바스크립트에는 포인터라는 개념이 없고, 값의 타입으로 값-복사인지 레퍼런스-복사인지 결정됨
- `null, undefined, string, number, boolean, symbol` 같은 스칼라 원시 값은 값-복사
- 객체나 함수 등 합성 값은 레퍼런스-복사
- 자바스크립트의 레퍼런스는 다른 언어의 레퍼런스/포인터와는 전혀 다름
    - 자신의 값만 가리킴
    
    ```jsx
    var a = [1,2,3]
    var b = a
    a // [1,2,3]
    b // [1,2,3]
    b = [4,5,6]
    a // [1,2,3]
    b // [4,5,6] b의 레퍼런스가 [4,5,6]으로 변경되었을 뿐 참조하던 a에는 아무 영향이 없음
    ```