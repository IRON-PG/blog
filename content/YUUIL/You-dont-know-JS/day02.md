---
title: "CH3. 네이티브 ~ CH4.4 암시적 강제변환"
metaTitle: "You don't Know JS Study-02"
metaDescription: "CH3. 네이티브 ~ CH4.4 암시적 강제변환"
author: "yuuil"
date: "2022-10-28"
---
# 3. 네이티브

자바스크립트의 네이티브는 내장 함수를 의미.

많이 쓰는 네이티브

- `String()`
- `Number()`
- `Boolean()`
- `Array()`
- `Object()`
- `Function()`
- `RegExp()`
- `Date()`
- `Error()`
- `Symbol()` - ES6+

## 내부 [[Class]]

- typeof가 object인 값은 `[[Class]]` 라는 내부 프로퍼티가 존재.
    - 직접 접근할 수 없으며, `Object.prototype.toString()` 메서드를 이용해 볼 수 있음.
    - ex) `Object.prototype.toString.call([1,2,3]) // "[object Array]"` , `Object.prototype.toString.call(/regex-literal/i) // "[object RegExp]"`
- 내부 [[Class]] 는 대부분 값과 관련된 내장 네이티브 생성자를 가리킴.
- FYI) 원시 값의 내부 [[Class]]
    - 네이티브 생성자가 없음: null → Null, undefined → Undefined
    - 박싱(단순 원시 값): string → String, number → Number, boolean → Boolean

## 박싱 / 언박싱

- 자바스크립트는 원시 값을 알아서 박싱함.
    - 직접 객체 형태로 선 최적화를 하는 것은 좋은 방법이 아님 → 브라우저가 스스로 최적화.
- 객체 래퍼의 원시 값은 `valueOf()` 메서드로 추출 가능함.

## 네이티브 생성자

### Array

- Array는 생성자 앞에 `new` 를 붙이지 않아도 붙인 것처럼 동작.
- Array의 크기를 미리 정해 빈 슬롯을 가지는 배열 생성 방식은 지양하자.
    - `map()` 메서드는 슬롯을 순회하지만 `join()` 은 슬롯이 있다는 가정하에 `length` 만큼 순회하기 때문에 빈 슬롯을 가진 배열과 `undefined` 로 세팅된 배열의 동작 방식은 엄연히 다름.
    - 브라우저/버전마다 배열을 표시하는 방식도 다르기 때문에 혼란 가중.
- `new Array(3)` 대신 `Array.apply(null, { length: 3})` 으로 모든 슬롯이 채워진 배열을 생성하자.
    - `Array.apply()` 는 `Array()` 함수를 호출하면서 `{length: 3}` 객체 값을 펼쳐 인자로 넣기 때문에 0~2 인덱스 모두 두 번째 인자로 주어진 객체에 존재하지 않기 때문에 `undefined` 를 반환.

### Object, Function, RegExp

- 일반적으로 생성자 사용은 권하지 않음.
- `RegExp()` 생성자는 정규 표현식 패턴을 동적으로 정의할 경우에만 사용하자.

### Date, Error

- Date와 Error는 리터럴 형식이 없는 네이티브 생성자.
- Error은 앞에 `new` 를 붙이지 않아도 결과가 같음.
- error 객체는 `.stack` 프로퍼티(읽기 전용)를 이용해 현재 실행 스택 컨텍스트에 접근이 가능.

### Symbol

- 충돌 염려 없이 객체 프로퍼티로 사용 가능한 유일 값.
    - **절대적으로 유일함이 보장되지 않음.**
    - 프로퍼티명으로 사용할 수 있으나, 코드나 콘솔 창에서 실제 값을 보거나 접근은 불가능.

*☁️ 심볼 값을 생성하는 로직과 심볼로 변환한 실제 값은 어디에 저장되어 있을까?*

- `new` 를 붙이면 에러가 나는 유일한 네이티브 생성자. → `Symbol()` 네이티브를 사용해 정의.

### 프로토타입

- 내장 네이티브 생성자는 `.prototype` 객체를 가짐.
    - 프로토타입을 추가하지 않고 네이티브 프로토타입을 변경하는 것은 권장하지 않음.
- FYI) 네이티브 프로토타입이 특별한 경우
    - `Function.prototype` → 빈 함수
    - `RegExp.prototype` → 빈 정규 표현식
    - `Array.prototype` → 빈 배열
    - 프로토타입으로 함수 인자의 디폴트 값을 세팅하면 딱 한 번 생성되기 때문에 함수가 호출될 때마다 디폴트 값을 다시 생성하지 않아 메모리/CPU 낭비를 줄일 수 있음. → 그치만 수정되는 변수 값이라면 이점 없음.

# 4. 강제변환

어떤 값을 다른 타입의 값으로 바꾸는 과정이 명시적이면 타입 캐스팅, 암시적이면 강제변환.

- 자바스크립트는 대부분의 타입변환을 강제변환으로 일컬음. 이 책에서는 아래 기준으로 두 가지로 구분함.

명시적 강제변환 - 코드에서 의도적으로 타입변환을 일으키는 게 명확한 타입변환.

암시적 강제변환 - 다른 작업 도중 불분명한 부수효과로 인해 발생하는 타입변환.

## 추상 연산

### ToString

- 숫자는 문자열로 바뀌고 너무 작거나 큰 값은 지수 형태로 바뀜.

JSON 문자열화

- JSON 안전 값은 모두 `JSON.stringify()` 로 문자열화 가능.
    - 안전 값이 아닌 것 - `undefined, 함수, 심볼, 순환 참조 객체 등`
    - 안전 값이 아닌 인자는 누락시키고, 배열에 포함되면 해당 인덱스의 값을 null로 바꾸고, 객체 프로퍼티에 있으면 지워버림.
    - 직렬화하기 힘든 객체 값을 문자열화하려면 직접 `toJSON()` 메서드를 정의하면 됨.
    - `toJSON()` 은 문자열 표현형이 아닌 반환해야 하는 실제 값을 반환하고 실제 문자열화 처리는 `JSON.stringify()` 가 함.
    - `JSON.stringify()` 의 두 번째 인자는 배열 / 함수 형태의 대체자로 `toJSON()` 과 비슷한 방식으로 직렬화할 수 있음.
    
    ```jsx
    var a = {
    	b: 42,
    	c: "42",
    	d: [1, 2, 3]
    }
    JSON.stringify(a, ["b", "c"]) // "{"b":42,"c":"42"}"
    JSON.stringify(a, function(k,v) {
    	if(k !== "c") return v;
    }) // "{"b":42,"d":[1,2,3]}"
    
    var o = {
    	val: [1,2,3],
    	toJSON: function() {
    		return this.val.slice(1);
    	}
    }
    JSON.stringify(o) // "[2,3]"
    ```
    

*☁️ 대체자랑 toJSON 동시에 주면 어떻게 될까*

### ToNumber

- 문자열은 숫자 리터럴과 비슷하게 동작하고 변환에 실패하면 `NaN` , 8진수는 일반 10진수로 처리.
- 객체는 `valueOf()` 메서드를 구현했는지 확인하고 반환 값이 원시 값이면 강제 변환, 아닌 경우 `toString()` 을 이용해 강제 변환.
- 원시 값으로 바꿀 수 없는 경우 `TypeError`

### ToBoolean

- `falsy` 한 값은 `false` , 그 외의 값은 `true`

Falsy 객체

- 객체는 truthy, falsy한 객체는 순수 자바스크립트가 아닌 브라우저의 특이한 동작 방식으로 인해 생성된 값.
- ex) IE의 `document.all` → 평범한 객체처럼 동작하지만 불리언으로 강제 변환하면 `false`

## 명시적 강제변환

- `String()`, `Number()` 를 이용해 추상 연산을 통해 변환되는 경우
- +/- 단항연산자
- 날짜
    - 날짜 타입은 강제 변환을 권하지 않음.
    - +new Date() 대신 타임 스탬프를 얻기 위해서는 `Date.now()` 나 `new Date().getTime()` 권장.
    - FYI) new Date()는 new Date로 써도 됨. 생성 호출 시 전달 인자가 없는 경우 괄호는 생략 가능한 일종의 자바스크립트 구문 트릭
- ~(틸드)
    - ~x는 대략 -(x+1)와 같음 ⇒ ~는 2의 보수를 구하는 연산.
    - x가 -1인 경우 falsy한 0이 나오고 그 외는 truthy한 숫자 값을 산출.
        - `indexOf()` 를 이용해 특정 문자열이 다른 문자열에 포함 여부를 조사할 때 유용.
    - 비트 잘라낼 때 `~~(더블 틸드)` 사용 가능.
        - 음수에서 `Math.floor()` 와 결과값이 다르므로 사용에 주의!
        - 비트 연산자 우선순위를 고려해 `x | 0` 를 쓰는 방법도 있음.
- 숫자 형태의 문자열 파싱
    - `parseInt()` 는 파싱 가능한 문자열까지만 강제변환. 비문자열이라면 강제로 문자열로 바꾼 다음 파싱.

## 암시적 변환

- 암시적 강제변환의 목적은 중요한 내용으로부터 주의를 분산시켜 불필요한 상세 구현을 줄이는 것.
- a + “”
    - `ToPrimitive` 연산 과정에서 a + “” 는 `valueOf()` 메서드를 호출하고 결과값을 `ToString` 추상 연산을 하지만 `String(a)` 는 `toString()` 을 직접 호출 ⇒ 따라서, a 가 객체 값이라면 주의해야 한다.
- true/truthy 를 숫자로 강제변환하면 1
    - *☁️ `Boolean({}) == true, Boolean([]) == true` 인데 `{} + [] == 0` 임. 왜?*
- && 와 || 연산자
    - 일반적인 논리 연산자와 동작 방식이 다름.
    - || 는 결과값이 true면 첫 번째 피연산자 값, false면 두 번째 피연산자 값 반환.
    - && 는 결과값이 true면 두 번째 피연산자 값, false면 첫 번째 피연산자 값 반환.
    - 다른 언어와는 달리 자바스크립트에서는 ||, && 모두 피연산자 값 중 하나를 반환함.
- 심볼
    - 명시적 강제변환으로 문자열 강제 변환은 가능하지만 암시적 강제변환은 금지 ⇒ `TypeError`