---
title: "[Day 03] CH 4.5 느슨한/엄격한 동등 비교 ~ CH 5.1 문과 표현식"
metaTitle: "You don't Know JS"
metaDescription: "CH 4.5 느슨한/엄격한 동등 비교 ~ CH 5.1 문과 표현식"
author: "paryyongwoo"
date: "2022-11-05"
---
# 챕터 4 강제변환

## 느슨한/엄격한 동등 비교

느슨한 동등 비교 (Loose Equals)는 “==” 연산자를, 엄격한 동등 비교 (Strict Equals)는 “===” 연산자를 사용한다. 두 연산자는 동등함의 판단 기준이 다른데 “==”는 값의 동등함을 “===”는 값과 타입의 동등함을 비교한다고 오해하기 쉽다. **실제로 이 둘의 차이점은 “==”는 동등함의 비교시 강제변환을 허용하지만, “===”는 강제변환을 허용하지 않는다는 점이다.**

### 비교 성능

“==”의 경우 비교하는 두 피연산자의 타입이 다른 경우 강제변환을 해야 하므로 처리 시간이 약간 더 소모된다. 다만 이는 워낙 짧은 시간내에 이루어져 성능상으로 크게 유의미하지는 않다. 중요한 사실은 “==”도 “===”와 마찬가지로 피연산자의 타입을 체크한다는 점이다.

### 추상 동등 비교

“==” 연산자 로직은 ES5 추상적 동등 비교 알고리즘에 상술되어있다. 모든 가능한 타입별 조합마다 (필요시) 강제변환을 어떻게 수행하는지 방법이 적혀있다.

“==” 연산의 경우 비교할 두 값이 같은 타입이면 값을 식별하는데, 예외 값도 존재한다.

- NaN은 그 자신과도 동등하지 않다.
- +0과 -0은 동등하지 않다.

객체를 비교하는 경우 두 객체가 정확히 똑같은 값에 대한 레퍼런스일 경우에만 동등하다고 여긴다.

명세의 다른 부분에는 타입이 다른 두 값을 느슨한 동등 비교시 한쪽 또는 양쪽 피연산자에서 암시적 강제변환을 어떻게 해야 하는지 적혀 있는데, **결과적으로 두 값의 타입을 일치시켜 간단히 값만 보고 비교하기 위함이다.**

**문자열과 숫자 비교하기**

```jsx
var a = 42;
var b = "42";

a === b; // false
a == b; // true
```

느슨한 동등 비교의 경우 두 비교값 중 String 타입인 값을 Number로 (암시적) 강제변환 후 비교한다.

**불리언값 비교하기**

```jsx
var a = "42";
var b = true;

a == b; // false
```

위의 코드에서 a는 truthy한 값이니 true로 암시적 강제변환되어 b와 같다고 생각할 수 있다. 그러나 명세에는 다른 방식으로 불리언 값을 비교한다고 명시되어있다.

1. Type(x)이 불리언이면 ToNumber(x) == y의 비교 결과를 반환한다.
2. Type(y)이 불리언이면 x == ToNumber(y)의 비교 결과를 반환한다.

즉 b의 타입이 불리언이므로 이는 Number로 변환되어 1이 된다. 이후 “42” == 1 연산이 수행되고 이는 문자열과 숫자 비교하기 알고리즘에 따라 문자열인 “42”가 42로 강제변환되어 42 == 1 연산이 수행된다. 두 값의 타입이 같으므로 단순 값 비교를 수행하고 결과는 false가 된다.

결국 느슨한 동등 비교로 불리언 값을 비교하는 경우 불리언 타입이 아닌 값의 truthy/falsy 여부는 전혀 상관이 없다. 단지 불리언 타입의 값이 Number로 변환 후 비교될 뿐이다.

**이러한 특성으로 인해 절대 불리언이 아닌 값에 대해 == true, == false 같은 코드는 쓰지 않는 것이 좋다.**

**null과 undefined 비교하기**

null과 undefiend의 느슨한 동등 비교 연산은 다음 규칙을 따른다.

1. x가 null이고 y가 undefined면 true를 반환한다.
2. x가 undefined이고 y가 null면 true를 반환한다.

즉 null과 undefined는 느슨한 동등 비교시 서로에게 타입을 맞춘다. (강제변환한다.)

이러한 규칙으로 인해 오히려 더 간결한 코드를 작성할 수 있게 되기도 한다.

```jsx
var a = doSomething();

// 느슨한 비교 연산자를 활용하여 undefined, null을 모두 체크한다. 사용하려나..
if (a == null) {}

// 위와 동일하다. 조금 더 명확하긴한데 약간 성능도 떨어진다고 한다.
if (a === undefined || a === null) {}
```

**객체와 비객체 비교하기**

객체와 단순 스칼라 원시 값의 비교는 다음 규칙을 따른다.

1. Type(x)가 String 또는 Number이고 Type(y)가 객체면, x == ToPrimitive(y)의 비교 결과를 반환한다.
2. Type(x)가 Object고 Type(y)가 String 또는 Number면, ToPrimitive(x) == y의 비교 결과를 반환한다.

```jsx
var a = 42;
var b = [42];

a == b; // true
```

위의 코드는 [42]가 ToPrimitive 추상 연산 결과로 “42”가 되고 “42” == 42는 42 == 42로 변환되어 true를 반환하게 된다.

다만 특이한 케이스가 있는데 null, undefined의 경우 객체 래퍼가 따로 없어 박싱할 수 없다. 그래서 Object(null)로 박싱한 결과는 Object()로 해석되어 일반 객체가 만들어진다.

또한 NaN은 Number 객체 래퍼로 박싱되지만, ==를 만나 언박싱되면 결국 조건식은 NaN == NaN이 되어 false를 반환한다.

```jsx
var a = null
var b = Object(a); // Object()와 같다.
a == b; // false

var e = NaN;
var f = Object(e); // new Number(e)와 같다.
e == f;  // false
```

**암시적 강제변환의 안전한 사용법**

책의 저자가 제안하는 동등 비교 원칙은 다음과 같다.

- 피연산자 중 하나가 true/false일 가능성이 있으면 ‘절대로’ == 연산자를 쓰지 말자.
- 피연산자 중 하나가 [], “”, 0이 될 가능성이 있으면 가급적 == 연산자를 쓰지 말자.

위의 상황이라면 “===” 연산자를 사용하여 의도하지 않은 강제변환을 차단하는게 좋다.

결국 암시적 강제변환이 무조건 나쁘다는 아니기에, 강제변환 (명시적, 암시적)의 강력함을 효과적이고 안전하게 사용하는 개발자가 되자……….

### 추상 관계 비교

추상적 관계 비교 알고리즘은 비교 시 피연산자 모두 문자열일 때와 그 외의 경우로 나뉜다.

어느 한쪽이라도 문자열이 아닌 경우 양쪽 모두 ToNumber로 강제변환하여 숫자 값으로 만들어 비교를 한다.

```jsx
var a = [42];
var b = ["43"];

a < b; // true
b < a; // false
```

위의 코드에서는 두 배열 모두 ToNumber 추상 연산을 하기 위해 먼저 ToPrimitive 강제변환을 실시한다. 그리하여 “42”, “43” 이라는 문자열이 나오고 이 둘을 Number로 변환하여 42 < 43을 비교하게 된다.

만약 두 대상이 모두 문자열이라면 각 문자를 단순 어휘 비교한다. (알파벳 순서)

객체의 비교는 다음과 같다.

```jsx
var a = { b: 42 };
var b = { b: 43 };

a < b; // false
```

추상 관계 비교 알고리즘에서 사용되는 암시적 강제변환을 이해하고 정확하게 사용하기 위해 단순히 42 < “43” 처럼 강제변환이 유용하고 어느 정도 안전한 관계 비교라면 그냥 쓰자. 그러나 조심해서 관계 비교를 해야할 것 같은 상황에서는 비교 전 비교할 값들을 명시적으로 강제변환해두는 편이 안전하다.

# 챕터 5 문법

## 문과 표현식

```jsx
var a = 3 * 6;
var b = 1;
b;
```

var a = 3 * 6, var b = a 두 문은 각각 변수를 선언(그리고 선택적으로 동시에 어떤 값을 할당)하므로 `선언문 (Declaration Statement)`이라 한다.

앞에 var가 빠진 a = 3 * 6, b = a는 `할당 표현식 (Assignment Expression)`이라고 한다.

세 번째 줄은 b가 표현식의 전부지만 이것만으로도 완전한 문이다. 이런 문을 `표현식 문 (Expression Statement)`라고 한다.

### 문의 완료 값

모든 문은 `완료 값 (Completion Value)`을 가진다. 완료 값을 보기 위한 가장 쉬운 방법은 브라우저 개발자 콘솔 창에서 문을 타이핑해보는 것이다.

```jsx
var a = 3 * 6; // 콘솔에 찍어보면 undefined가 출력된다.
var b = a; // 콘솔에 찍어보면 undefined가 출력된다.
b = a; // 콘솔에 찍어보면 18이 출력된다.
```

할당 표현식 (b = a;)의 완료값은 18이 나오지만 var 문 자체의 완료값은 undefined가 나오는데, 이는 명세서에 명시되어있다.

보통의 {} 블럭은 내부의 가장 마지막 문/표현식의 완료 값을 자신의 완료 값으로 반환한다. 아래 코드를 개발자 도구 콘솔에 찍어보면 if문 {} 블럭 가장 아래의 b = 4 + 38;의 완료 값인 42가 출력된다.

```jsx
var b;

if (true) {
	b = 4 + 38;
}
```

하지만 완료 값이 반환된다고 해서 다음과 같은 코드는 작성할 수 없다. 왜냐하면 문의 완료 값을 포착하여 다른 변수에 할당하는건 일반 구문/문법으로는 불가능하기 때문이다.

```jsx
var a, b;

a = if (true) {
	b = 4 + 38;
};
```

이를 꼭 하고 싶다면 eval을 사용할 수 있으나 권장되지는 않고, ~~ES7 명세에는 ‘do 표현식’이 제안되어 이를 가능하게 해준다.~~ → ES7 명세에 제안했다고만 한다.

```jsx
var a, b;

a = do {
	if (true) {
		b = 4 + 38;
	}
};

a; // 42
```

### 표현식의 부수효과

다음 표현식들은 부수 효과를 가진 예시이다.

- 함수 내부에서 외부 변수의 값을 변경하는 경우
- 증가 연산자 (++), 감소 연산자 (—)
- delete 연산자
- = (할당 연산자)

할당 표현식/문 실행 시 할당된 값이 완료 값이 되는 작동 원리는 다음과 같은 연쇄 할당문에서 특히 유용하다.

```jsx
var a, b, c;
a = b = c = 42;
```

**콘텍스트 규칙**

자바스크립트는 같은 구문이어도 어디에서, 어떻게 사용하냐에 따라 다른 의미를 가지는 경우가 있다.

**중괄호**

자바스크립트에서 중괄호가 나올 법한 곳은 크게 2가지이다.

1. 객체 리터럴
2. 레이블

아래 코드는 문법적으로 문제가 없을까?

```jsx
{
	foo: bar()
}
```

{}는 마치 객체 리터럴처럼 보이지만 여기서는 코드 블럭을 의미한다. 별도의 스코프를 지닌 문법적으로는 옳은 코드이다. 그런데 특이한 점은 `foo: bar()` 인데, 해당 문법은 레이블 문이라고 부르는 문법이다. 이는 마치 goto문과 유사한데, 자바스크립트에서는 goto를 지원하지 않지만 제한적으로 레이블 점프 (Labeled Jump)라는 형태의 goto 장치를 제공한다.

```jsx
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`(${i},${j})의 값`, '');
    // 사용자가 아무것도 입력하지 않거나 Cancel 버튼을 누르면 두 반복문 모두를 빠져나옵니다.
    if (!input) break outer;
  }
}
```

다만 권장되는 방식은 아니기에 자주 사용할 일은 없을 것 같다.

흔히 JSON이 자바스크립트의 고유의 하위 집합이라 생각하는 경우가 많다. 그래서 JSON 문자열이 유효한 자바스크립트 프로그램이라고 착각하게 된다. {”a”: 42}를 콘솔창에 입력하면 에러가 나는데, 이는 자바스크립트에서 “a”는 문법에 맞는 레이블이 아니라고 인식하기 때문이다. JSON-P 방식은 JSON 데이터를 함수 호출로 감싸는 패턴인데, 이를 활용하여 위와 같은 에러를 해결한다.

**블록**

```jsx
[] + {}; // "[object Object]"
{} + []; // 0
```

윗줄은 []는 강제변환에 의해 “”으로 해석되고 {}는 빈 객체로 인식하여 “[object Object]”가 반환된다.

아랫줄의 {}는 빈 블록으로 간주하고 + [] 표현식에서 명시적으로 []를 숫자 0으로 강제변환된다.

**객체 분해**

```jsx
var { a, b } = getData();
```

객체 분해 문법에서도  {, }가 사용된다.

**else if와 선택적 블록**

else if가 자바스크립트에 존재하는 문법이라 오해하기 쉬운데 사실은 if문과 else문으로 분리하여 해석된다.

```jsx
if (a) {}
else if (b) {}
else {}

// 아래의 방식으로 파싱된다.

if (a) {}
else {
	if (b) {}
	else {}
}
```

else if는 누구나 다 쓰는 관용 코드이고, 한 단계 하위로 들여 쓰기를 하는 효과가 있어 자신의 스타일 가이드와 규칙을 명시적으로 준수하면 된다. 다만 else if가 정확한 문법 규칙이 아니라는 사실만 인지하자.
